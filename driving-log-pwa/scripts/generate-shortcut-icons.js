const fs = require('fs');
const path = require('path');

// „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç¢„Ç§„Ç≥„É≥„ÅÆÂÆöÁæ©
const shortcutIcons = [
    {
        name: 'new-log',
        description: 'Êñ∞Ë¶èÈÅãËª¢Ë®òÈå≤',
        emoji: '‚ûï',
        color: '#4CAF50',
        backgroundColor: '#E8F5E8'
    },
    {
        name: 'history',
        description: 'Â±•Ê≠¥Ë°®Á§∫',
        emoji: 'üìä',
        color: '#2196F3',
        backgroundColor: '#E3F2FD'
    },
    {
        name: 'settings',
        description: 'Ë®≠ÂÆö',
        emoji: '‚öôÔ∏è',
        color: '#757575',
        backgroundColor: '#F5F5F5'
    },
    {
        name: 'export',
        description: '„Ç®„ÇØ„Çπ„Éù„Éº„Éà',
        emoji: 'üì§',
        color: '#FF9800',
        backgroundColor: '#FFF3E0'
    },
    {
        name: 'location',
        description: 'ÁèæÂú®Âú∞Ë®òÈå≤',
        emoji: 'üìç',
        color: '#F44336',
        backgroundColor: '#FFEBEE'
    },
    {
        name: 'sync',
        description: '„Ç™„Éï„É©„Ç§„É≥ÂêåÊúü',
        emoji: 'üîÑ',
        color: '#9C27B0',
        backgroundColor: '#F3E5F5'
    }
];

// „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç¢„Ç§„Ç≥„É≥SVGÁîüÊàê
const generateShortcutIconSVG = (icon, size) => {
    const { name, emoji, color, backgroundColor } = icon;
    const center = size / 2;
    const emojiSize = size * 0.5;
    
    return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
  <!-- Background Circle -->
  <circle cx="${center}" cy="${center}" r="${size * 0.45}" fill="${backgroundColor}" stroke="${color}" stroke-width="${size * 0.02}"/>
  
  <!-- Emoji Icon -->
  <text x="${center}" y="${center}" 
        font-family="Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif" 
        font-size="${emojiSize}" 
        text-anchor="middle" 
        dominant-baseline="central">${emoji}</text>
  
  <!-- Optional Border -->
  <circle cx="${center}" cy="${center}" r="${size * 0.45}" fill="none" stroke="${color}" stroke-width="${size * 0.01}" opacity="0.3"/>
</svg>`;
};

// „Çà„ÇäË©≥Á¥∞„Å™„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç¢„Ç§„Ç≥„É≥„ÅÆÁîüÊàêÔºà„Éô„ÇØ„Çø„ÉºÔºâ
const generateDetailedShortcutIconSVG = (icon, size) => {
    const { name, color, backgroundColor } = icon;
    const center = size / 2;
    
    let iconPath = '';
    
    switch (name) {
        case 'new-log':
            iconPath = `
                <g transform="translate(${center - size * 0.15}, ${center - size * 0.15})">
                    <circle cx="${size * 0.15}" cy="${size * 0.15}" r="${size * 0.12}" fill="none" stroke="${color}" stroke-width="${size * 0.02}"/>
                    <line x1="${size * 0.15}" y1="${size * 0.08}" x2="${size * 0.15}" y2="${size * 0.22}" stroke="${color}" stroke-width="${size * 0.02}" stroke-linecap="round"/>
                    <line x1="${size * 0.08}" y1="${size * 0.15}" x2="${size * 0.22}" y2="${size * 0.15}" stroke="${color}" stroke-width="${size * 0.02}" stroke-linecap="round"/>
                </g>`;
            break;
            
        case 'history':
            iconPath = `
                <g transform="translate(${center - size * 0.15}, ${center - size * 0.15})">
                    <rect x="${size * 0.05}" y="${size * 0.08}" width="${size * 0.2}" height="${size * 0.14}" rx="${size * 0.01}" fill="none" stroke="${color}" stroke-width="${size * 0.015}"/>
                    <line x1="${size * 0.08}" y1="${size * 0.12}" x2="${size * 0.22}" y2="${size * 0.12}" stroke="${color}" stroke-width="${size * 0.01}"/>
                    <line x1="${size * 0.08}" y1="${size * 0.15}" x2="${size * 0.18}" y2="${size * 0.15}" stroke="${color}" stroke-width="${size * 0.01}"/>
                    <line x1="${size * 0.08}" y1="${size * 0.18}" x2="${size * 0.2}" y2="${size * 0.18}" stroke="${color}" stroke-width="${size * 0.01}"/>
                </g>`;
            break;
            
        case 'settings':
            iconPath = `
                <g transform="translate(${center}, ${center})">
                    <circle r="${size * 0.06}" fill="none" stroke="${color}" stroke-width="${size * 0.015}"/>
                    <g stroke="${color}" stroke-width="${size * 0.01}" stroke-linecap="round">
                        <line x1="0" y1="${-size * 0.12}" x2="0" y2="${-size * 0.09}"/>
                        <line x1="0" y1="${size * 0.09}" x2="0" y2="${size * 0.12}"/>
                        <line x1="${size * 0.104}" y1="${-size * 0.06}" x2="${size * 0.078}" y2="${-size * 0.045}"/>
                        <line x1="${-size * 0.078}" y1="${size * 0.045}" x2="${-size * 0.104}" y2="${size * 0.06}"/>
                        <line x1="${size * 0.104}" y1="${size * 0.06}" x2="${size * 0.078}" y2="${size * 0.045}"/>
                        <line x1="${-size * 0.078}" y1="${-size * 0.045}" x2="${-size * 0.104}" y2="${-size * 0.06}"/>
                    </g>
                </g>`;
            break;
            
        case 'export':
            iconPath = `
                <g transform="translate(${center - size * 0.1}, ${center - size * 0.12})">
                    <rect x="0" y="${size * 0.04}" width="${size * 0.2}" height="${size * 0.16}" rx="${size * 0.01}" fill="none" stroke="${color}" stroke-width="${size * 0.015}"/>
                    <path d="M ${size * 0.1} ${size * 0.04} L ${size * 0.1} ${-size * 0.02} M ${size * 0.06} ${size * 0.02} L ${size * 0.1} ${-size * 0.02} L ${size * 0.14} ${size * 0.02}" 
                          fill="none" stroke="${color}" stroke-width="${size * 0.015}" stroke-linecap="round" stroke-linejoin="round"/>
                </g>`;
            break;
            
        case 'location':
            iconPath = `
                <g transform="translate(${center}, ${center - size * 0.05})">
                    <path d="M 0 ${-size * 0.08} C ${-size * 0.05} ${-size * 0.08} ${-size * 0.08} ${-size * 0.05} ${-size * 0.08} 0 
                             C ${-size * 0.08} ${size * 0.03} 0 ${size * 0.12} 0 ${size * 0.12} 
                             C 0 ${size * 0.12} ${size * 0.08} ${size * 0.03} ${size * 0.08} 0 
                             C ${size * 0.08} ${-size * 0.05} ${size * 0.05} ${-size * 0.08} 0 ${-size * 0.08} Z"
                          fill="none" stroke="${color}" stroke-width="${size * 0.015}"/>
                    <circle r="${size * 0.025}" fill="${color}"/>
                </g>`;
            break;
            
        case 'sync':
            iconPath = `
                <g transform="translate(${center}, ${center})">
                    <path d="M ${-size * 0.08} ${-size * 0.04} C ${-size * 0.08} ${-size * 0.08} ${-size * 0.04} ${-size * 0.12} 0 ${-size * 0.12}
                             C ${size * 0.04} ${-size * 0.12} ${size * 0.08} ${-size * 0.08} ${size * 0.08} ${-size * 0.04}"
                          fill="none" stroke="${color}" stroke-width="${size * 0.015}" stroke-linecap="round"/>
                    <path d="M ${size * 0.08} ${size * 0.04} C ${size * 0.08} ${size * 0.08} ${size * 0.04} ${size * 0.12} 0 ${size * 0.12}
                             C ${-size * 0.04} ${size * 0.12} ${-size * 0.08} ${size * 0.08} ${-size * 0.08} ${size * 0.04}"
                          fill="none" stroke="${color}" stroke-width="${size * 0.015}" stroke-linecap="round"/>
                    <path d="M ${size * 0.05} ${-size * 0.06} L ${size * 0.08} ${-size * 0.04} L ${size * 0.06} ${-size * 0.01}"
                          fill="none" stroke="${color}" stroke-width="${size * 0.01}" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M ${-size * 0.05} ${size * 0.06} L ${-size * 0.08} ${size * 0.04} L ${-size * 0.06} ${size * 0.01}"
                          fill="none" stroke="${color}" stroke-width="${size * 0.01}" stroke-linecap="round" stroke-linejoin="round"/>
                </g>`;
            break;
    }
    
    return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
  <!-- Background Circle -->
  <circle cx="${center}" cy="${center}" r="${size * 0.45}" fill="${backgroundColor}"/>
  
  <!-- Icon Path -->
  ${iconPath}
  
  <!-- Border -->
  <circle cx="${center}" cy="${center}" r="${size * 0.45}" fill="none" stroke="${color}" stroke-width="${size * 0.02}" opacity="0.6"/>
</svg>`;
};

// „Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
const iconsDir = path.join(__dirname, '..', 'public', 'icons');
if (!fs.existsSync(iconsDir)) {
    fs.mkdirSync(iconsDir, { recursive: true });
}

console.log('üé® „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç¢„Ç§„Ç≥„É≥„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô...');

// ÂêÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÅÆ„Ç¢„Ç§„Ç≥„É≥„ÇíÁîüÊàê
shortcutIcons.forEach(icon => {
    // 96x96 „Çµ„Ç§„Ç∫ÔºàemojiÁâàÔºâ
    const emoji96 = generateShortcutIconSVG(icon, 96);
    const emojiPath96 = path.join(iconsDir, `shortcut-${icon.name}.svg`);
    fs.writeFileSync(emojiPath96, emoji96);
    console.log(`‚úÖ ÁîüÊàêÂÆå‰∫Ü: shortcut-${icon.name}.svg (96x96 emoji)`);
    
    // 192x192 „Çµ„Ç§„Ç∫ÔºàemojiÁâàÔºâ
    const emoji192 = generateShortcutIconSVG(icon, 192);
    const emojiPath192 = path.join(iconsDir, `shortcut-${icon.name}-192.svg`);
    fs.writeFileSync(emojiPath192, emoji192);
    console.log(`‚úÖ ÁîüÊàêÂÆå‰∫Ü: shortcut-${icon.name}-192.svg (192x192 emoji)`);
    
    // 96x96 „Çµ„Ç§„Ç∫Ôºà„Éô„ÇØ„Çø„ÉºÁâàÔºâ
    const vector96 = generateDetailedShortcutIconSVG(icon, 96);
    const vectorPath96 = path.join(iconsDir, `shortcut-${icon.name}-vector.svg`);
    fs.writeFileSync(vectorPath96, vector96);
    console.log(`‚úÖ ÁîüÊàêÂÆå‰∫Ü: shortcut-${icon.name}-vector.svg (96x96 vector)`);
    
    // 192x192 „Çµ„Ç§„Ç∫Ôºà„Éô„ÇØ„Çø„ÉºÁâàÔºâ
    const vector192 = generateDetailedShortcutIconSVG(icon, 192);
    const vectorPath192 = path.join(iconsDir, `shortcut-${icon.name}-vector-192.svg`);
    fs.writeFileSync(vectorPath192, vector192);
    console.log(`‚úÖ ÁîüÊàêÂÆå‰∫Ü: shortcut-${icon.name}-vector-192.svg (192x192 vector)`);
});

// „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÁÆ°ÁêÜJS„Éï„Ç°„Ç§„É´
const shortcutManagerPath = path.join(__dirname, '..', 'public', 'shortcuts', 'shortcuts-manager.js');
const shortcutManagerContent = `/**
 * ÈÅãËª¢Êó•Â†±PWA - „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÁÆ°ÁêÜ
 * ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Å® „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Éô„Éº„Çπ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÅÆÁÆ°ÁêÜ
 */

class ShortcutsManager {
    constructor() {
        this.config = null;
        this.dynamicShortcuts = [];
        this.contextualShortcuts = [];
        this.analytics = {
            usage: new Map(),
            sources: new Map()
        };
        
        this.init();
    }

    /**
     * ÂàùÊúüÂåñ
     */
    async init() {
        try {
            // Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
            const response = await fetch('/shortcuts/shortcuts-config.json');
            this.config = await response.json();
            
            // ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíË©ï‰æ°„ÉªÊõ¥Êñ∞
            this.updateDynamicShortcuts();
            
            // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíË©ï‰æ°„ÉªÊõ¥Êñ∞
            this.updateContextualShortcuts();
            
            // ‰ΩøÁî®Áä∂Ê≥Å„ÅÆËøΩË∑°„ÇíÈñãÂßã
            if (this.config.settings.analytics.track_usage) {
                this.initAnalytics();
            }
            
            console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÁÆ°ÁêÜ„ÅåÂàùÊúüÂåñ„Åï„Çå„Åæ„Åó„Åü');
        } catch (error) {
            console.error('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
        }
    }

    /**
     * ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÅÆÊõ¥Êñ∞
     */
    updateDynamicShortcuts() {
        if (!this.config?.dynamic_shortcuts) return;

        this.dynamicShortcuts = this.config.dynamic_shortcuts.filter(shortcut => {
            return this.evaluateCondition(shortcut.condition, shortcut);
        });

        console.log('ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÊõ¥Êñ∞:', this.dynamicShortcuts.length);
    }

    /**
     * „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÅÆÊõ¥Êñ∞
     */
    updateContextualShortcuts() {
        if (!this.config?.contextual_shortcuts) return;

        this.contextualShortcuts = this.config.contextual_shortcuts.filter(shortcut => {
            return this.evaluateCondition(shortcut.condition, shortcut);
        });

        console.log('„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÊõ¥Êñ∞:', this.contextualShortcuts.length);
    }

    /**
     * Êù°‰ª∂„ÅÆË©ï‰æ°
     * @param {string} condition - Ë©ï‰æ°„Åô„ÇãÊù°‰ª∂
     * @param {object} shortcut - „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
     * @returns {boolean} Êù°‰ª∂„ÇíÊ∫Ä„Åü„Åô„Åã„Å©„ÅÜ„Åã
     */
    evaluateCondition(condition, shortcut) {
        switch (condition) {
            case 'has_recent_logs':
                return this.hasRecentLogs(shortcut.max_age_days || 7);
            
            case 'has_incomplete_logs':
                return this.hasIncompleteLogs();
            
            case 'not_driving':
                return !this.isDriving();
            
            case 'is_driving':
                return this.isDriving();
            
            default:
                return false;
        }
    }

    /**
     * ÊúÄËøë„ÅÆ„É≠„Ç∞„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
     * @param {number} maxAgeDays - ÊúÄÂ§ßÊó•Êï∞
     * @returns {boolean}
     */
    hasRecentLogs(maxAgeDays) {
        // StorageService „Åæ„Åü„ÅØ„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó
        try {
            const logs = JSON.parse(localStorage.getItem('driving-logs') || '[]');
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
            
            return logs.some(log => new Date(log.createdAt) > cutoffDate);
        } catch (error) {
            console.error('ÊúÄËøë„ÅÆ„É≠„Ç∞„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
            return false;
        }
    }

    /**
     * Êú™ÂÆå‰∫Ü„ÅÆ„É≠„Ç∞„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
     * @returns {boolean}
     */
    hasIncompleteLogs() {
        try {
            const logs = JSON.parse(localStorage.getItem('driving-logs') || '[]');
            return logs.some(log => log.status === 'in_progress');
        } catch (error) {
            console.error('Êú™ÂÆå‰∫Ü„É≠„Ç∞„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
            return false;
        }
    }

    /**
     * ÁèæÂú®ÈÅãËª¢‰∏≠„Åã„ÉÅ„Çß„ÉÉ„ÇØ
     * @returns {boolean}
     */
    isDriving() {
        try {
            const currentSession = localStorage.getItem('current-driving-session');
            return currentSession !== null;
        } catch (error) {
            console.error('ÈÅãËª¢Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
            return false;
        }
    }

    /**
     * ÂÖ®„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíÂèñÂæó
     * @returns {array} „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÈÖçÂàó
     */
    getAllShortcuts() {
        const shortcuts = [...(this.config?.shortcuts || [])];
        
        if (this.config?.settings?.show_dynamic) {
            shortcuts.push(...this.dynamicShortcuts);
        }
        
        if (this.config?.settings?.show_contextual) {
            shortcuts.push(...this.contextualShortcuts);
        }
        
        // ÊúÄÂ§ßÊï∞Âà∂Èôê
        const maxShortcuts = this.config?.settings?.max_shortcuts || 4;
        return shortcuts.slice(0, maxShortcuts);
    }

    /**
     * „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰ΩøÁî®„ÅÆË®òÈå≤
     * @param {string} shortcutName - „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÂêç
     * @param {string} source - Âëº„Å≥Âá∫„ÅóÂÖÉ
     */
    recordUsage(shortcutName, source = 'unknown') {
        if (!this.config?.settings?.analytics?.track_usage) return;

        // ‰ΩøÁî®ÂõûÊï∞„ÇíË®òÈå≤
        const currentCount = this.analytics.usage.get(shortcutName) || 0;
        this.analytics.usage.set(shortcutName, currentCount + 1);

        // „ÇΩ„Éº„Çπ„ÇíË®òÈå≤
        if (this.config.settings.analytics.track_source) {
            const sourceCount = this.analytics.sources.get(source) || 0;
            this.analytics.sources.set(source, sourceCount + 1);
        }

        // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
        this.saveAnalytics();

        console.log(\`„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰ΩøÁî®Ë®òÈå≤: \${shortcutName} (from: \${source})\`);
    }

    /**
     * „Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„Çπ„ÅÆÂàùÊúüÂåñ
     */
    initAnalytics() {
        try {
            const savedAnalytics = localStorage.getItem('shortcuts-analytics');
            if (savedAnalytics) {
                const data = JSON.parse(savedAnalytics);
                this.analytics.usage = new Map(data.usage || []);
                this.analytics.sources = new Map(data.sources || []);
            }
        } catch (error) {
            console.error('„Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„ÇπÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
        }
    }

    /**
     * „Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„Çπ„ÅÆ‰øùÂ≠ò
     */
    saveAnalytics() {
        try {
            const data = {
                usage: Array.from(this.analytics.usage.entries()),
                sources: Array.from(this.analytics.sources.entries()),
                lastUpdated: Date.now()
            };
            localStorage.setItem('shortcuts-analytics', JSON.stringify(data));
        } catch (error) {
            console.error('„Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„Çπ‰øùÂ≠ò„Ç®„É©„Éº:', error);
        }
    }

    /**
     * „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÁµ±Ë®à„ÇíÂèñÂæó
     * @returns {object} Áµ±Ë®à„Éá„Éº„Çø
     */
    getStatistics() {
        return {
            totalShortcuts: this.config?.shortcuts?.length || 0,
            dynamicShortcuts: this.dynamicShortcuts.length,
            contextualShortcuts: this.contextualShortcuts.length,
            usage: Object.fromEntries(this.analytics.usage),
            sources: Object.fromEntries(this.analytics.sources),
            mostUsed: this.getMostUsedShortcut(),
            leastUsed: this.getLeastUsedShortcut()
        };
    }

    /**
     * ÊúÄ„ÇÇ‰ΩøÁî®„Åï„Çå„Åü„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíÂèñÂæó
     * @returns {object|null}
     */
    getMostUsedShortcut() {
        if (this.analytics.usage.size === 0) return null;
        
        const entries = Array.from(this.analytics.usage.entries());
        entries.sort((a, b) => b[1] - a[1]);
        
        return {
            name: entries[0][0],
            count: entries[0][1]
        };
    }

    /**
     * ÊúÄ„ÇÇ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíÂèñÂæó
     * @returns {object|null}
     */
    getLeastUsedShortcut() {
        if (this.analytics.usage.size === 0) return null;
        
        const entries = Array.from(this.analytics.usage.entries());
        entries.sort((a, b) => a[1] - b[1]);
        
        return {
            name: entries[0][0],
            count: entries[0][1]
        };
    }

    /**
     * Ëá™ÂãïÊõ¥Êñ∞„ÅÆÈñãÂßã
     */
    startAutoUpdate() {
        if (!this.config?.settings?.auto_update) return;

        // 30Áßí„Åî„Å®„Å´ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíÊõ¥Êñ∞
        setInterval(() => {
            this.updateDynamicShortcuts();
            this.updateContextualShortcuts();
        }, 30000);

        console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàËá™ÂãïÊõ¥Êñ∞„ÇíÈñãÂßã');
    }

    /**
     * „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàUI„ÇíÊõ¥Êñ∞
     */
    updateUI() {
        const shortcuts = this.getAllShortcuts();
        const event = new CustomEvent('shortcuts-updated', {
            detail: { shortcuts }
        });
        
        window.dispatchEvent(event);
    }
}

// „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
window.shortcutsManager = new ShortcutsManager();

// URL „Éë„É©„É°„Éº„Çø„Åã„Çâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰ΩøÁî®„ÇíÊ§úÂá∫
document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const source = urlParams.get('source');
    
    if (source && source.includes('shortcut')) {
        const shortcutName = window.location.pathname.split('/')[1] || 'unknown';
        window.shortcutsManager.recordUsage(shortcutName, source);
    }
});

export default ShortcutsManager;`;

const shortcutsDir = path.join(__dirname, '..', 'public', 'shortcuts');
if (!fs.existsSync(shortcutsDir)) {
    fs.mkdirSync(shortcutsDir, { recursive: true });
}

fs.writeFileSync(shortcutManagerPath, shortcutManagerContent);
console.log('‚úÖ ÁîüÊàêÂÆå‰∫Ü: shortcuts-manager.js');

console.log('\nüéâ „Åô„Åπ„Å¶„ÅÆ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Éï„Ç°„Ç§„É´„ÅåÁîüÊàê„Åï„Çå„Åæ„Åó„ÅüÔºÅ');

console.log('\nüìÅ ÁîüÊàê„Åï„Çå„Åü„Ç¢„Ç§„Ç≥„É≥„Éï„Ç°„Ç§„É´:');
shortcutIcons.forEach(icon => {
    console.log(`   shortcut-${icon.name}.svg (96x96 emoji)`);
    console.log(`   shortcut-${icon.name}-192.svg (192x192 emoji)`);
    console.log(`   shortcut-${icon.name}-vector.svg (96x96 vector)`);
    console.log(`   shortcut-${icon.name}-vector-192.svg (192x192 vector)`);
});

console.log('\nüìù ÂÆüË£ÖÂÜÖÂÆπ:');
console.log('- Âü∫Êú¨„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà (6Á®ÆÈ°û)');
console.log('- ÂãïÁöÑ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà (Êù°‰ª∂„Å´Âü∫„Å•„ÅèË°®Á§∫)');
console.log('- „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà (Áä∂Ê≥Å„Å´Âøú„Åò„ÅüË°®Á§∫)');
console.log('- „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰ΩøÁî®Áä∂Ê≥ÅÂàÜÊûê');
console.log('- Ëá™ÂãïÊõ¥Êñ∞Ê©üËÉΩ');

module.exports = {
    generateShortcutIconSVG,
    generateDetailedShortcutIconSVG,
    shortcutIcons
};